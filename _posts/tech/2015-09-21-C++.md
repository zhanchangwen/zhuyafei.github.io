---
layout: post
title: C/C++基本概念梳理
category: 技术
---

## 1. 面向对象的多态性
多态是一个事物有多种形态的意思。面向对象的多态性指的是对不同类的对象发送同一个消息，这些不同类的对象在接收时会有不同的行为。也就是说，当我们调用同一形式的函数时，不同类的对象分别执行功能不同的函数。多态性分为两类：静态多态性和动态多态性，又称编译时的多态性和运行时的多态性。静态多态性是通过函数重载和运算符重载实现的。动态多态性通过虚函数来实现。

当一个基类被继承为不同的派生类时，各个派生类可以使用与基类成员相同的成员名，那么编译系统会按照同名覆盖(派生类的函数覆盖基类中的同名函数)的原则决定如何调用。如果有某派生类对象，它调用基类成员函数和派生类中的同名成员函数的形式是不一样的，这样很不方便。并且，如果用指向基类的指针指向某一派生类对象，用这个指针调用派生类成员函数会失败，这是因为会自动进行指针类型转换，将派生类对象的指针转换为基类的指针，这样，基类指针指向的是派生类对象中的基类部分。于是想有一种方法可以用同一个调用形式来调用派生类和基类的同名函数。这就用到虚函数，虚函数，就是在基类中声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数，也就是派生类可以改变基类同名函数的行为。这样在运行时，用指向基类的指针指向某一派生类对象，通过该指针可以调用派生类中的成员函数。现在用同一种调用形式pt->display()，而且pt是同一个基类指针，可以调用同一类族中不同类的虚函数。

## 2. C++的类和C里面的struct有什么区别？
C++的class具有数据封装功能，其中各成员的访问属性可以是private，public和protect，还具有能实现类接口功能和辅助功能的操作函数，而C里面的struct访问权限只有public，没有数据封装功能，并且struct本身不含有操作函数，只有数据。

但是现在C++中仍然保留了C里面的结构体类型(struct)，并且把它的功能扩展了。C++里的结构体类型也可以包括成员函数，也具有类的特点(封装)，两者的区别是用struct声明的类，如果对其成员不作private或public的声明，系统将其默认为public。而用class定义的类，如果不作private或public的声明，系统将其成员默认为private。

## 3. 作用域和存储器
变量的两种属性：作用域和存储期(也称生命期)。

作用域是从空间的角度来分析的，分为全局变量和局部变量。在一个函数内部定义的变量是内部变量，它只在本函数范围内有效，这些内部变量称为局部变量。在函数之外定义的变量是外部变量，称为全局变量。

存储期是指变量在内存中的存在周期。存储期可以分为静态存储期和动态存储期。这是由变量的静态存储方式和动态存储方式决定的。所谓静态存储方式是指在程序运行期间，系统对变量分配固定的存储空间。而动态存储方式则是在程序运行期间，系统对变量动态地分配存储空间。

内存中供用户使用的存储空间可以分为3部分，即

* 程序区
* 静态存储区
* 动态存储区

程序中所用的数据分别存放在静态存储区和动态存储区中。全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储单元，程序执行完毕就释放这些空间。在程序执行过程中它们占据固定的存储单元。
在动态存储区中存放以下数据：

		* 函数形式参数
		* 函数中定义变量(未加static声明的局部变量)
		* 函数调用时的现场保护和返回地址等

对以上这些数据，在函数调用开始时分配动态存储空间，函数调用结束时释放这些空间。在程序执行过程中，这种分配和释放是动态的。

## 4. 如何判断变量的作用域和存储期？
要判断变量的作用域和存储期，除了要看变量是在函数内还是函数外定义的，还要看它们的存储类别，这是变量除了数据类型外的另一属性。
存储类别有4种：自动的(`auto`)，静态的(`static`)，寄存器的(`register`)，外部的(`extern`)。

* auto
	auto关键字用于声明函数中的局部变量，编译系统对它们是动态地分配存储空间的，这类局部变量称为自动变量，关键字auto可以省略。
* static
	* 用static声明局部变量
		

